import json
import os
from openpyxl import load_workbook, Workbook
import unicodedata
import re
from copy import copy
from openpyxl.cell.cell import Cell
from datetime import datetime

def _normalize_name(name: str) -> str:
    return unicodedata.normalize("NFKC", name.replace("　", " ")).strip()

# Updated time mapping based on actual Excel template
TIME_ROW_MAP = {
    "13:10": 5,
    "14:40": 6,
    "16:30": 7,
    "18:00": 8,
    "19:30": 9,
}

def copy_worksheet_template(target_wb, template_ws, new_title):
    new_ws = target_wb.create_sheet(title=new_title)
    for row in template_ws.iter_rows():
        for cell in row:
            if not isinstance(cell, Cell):  # Skip MergedCell
                continue
            new_cell = new_ws.cell(row=cell.row, column=cell.column, value=cell.value)
            if cell.has_style:
                new_cell.font = copy(cell.font)
                new_cell.border = copy(cell.border)
                new_cell.fill = copy(cell.fill)
                new_cell.number_format = copy(cell.number_format)
                new_cell.protection = copy(cell.protection)
                new_cell.alignment = copy(cell.alignment)

    for merged_range in template_ws.merged_cells.ranges:
        new_ws.merge_cells(str(merged_range))

    return new_ws

class Schedule_result:
    def __init__(self, student_data, teacher_data, match_data, student_template, teacher_template):
        self.student_data = {
            _normalize_name(k): v for k, v in student_data.items()
        }
        self.teacher_data = {
            _normalize_name(k): v for k, v in teacher_data.items()
        }
        self.subject_data = match_data
        self.student_template = student_template
        self.teacher_template = teacher_template

        self.teacher_output_path = "output/teachers_schedule.xlsx"
        self.student_output_dirs = {
            'elementary': "output/students_elementary.xlsx",
            'middle': "output/students_middle.xlsx",
            'high': "output/students_high.xlsx",
        }
        self.schedule_data = []
        self.date_order = []

    def run(self):
        self.generate_schedule()
        self.generate_teacher_excel()
        self.generate_student_excels()

    def generate_schedule(self):
        matched_pairs = set()
        teacher_daily_count = {}
        student_daily_count = {}

        for entry in self.subject_data:
            full_name = _normalize_name(entry.get('student_name', ''))
            grade = entry.get('grade', 'other')
            if full_name not in self.student_data:
                continue

            for subj in entry.get('subjects', []):
                if not isinstance(subj, dict):
                    continue

                subject = subj.get('name')
                teacher_avail = { _normalize_name(k): v for k, v in self.teacher_data.items() }
                raw_teacher = subj.get('teacher', '')
                if isinstance(raw_teacher, dict):
                    teacher = _normalize_name(raw_teacher.get('name', ''))
                else:
                    teacher = _normalize_name(raw_teacher)

                subject_type = '特別' if subj.get('special_classes', 0) > 0 else '通常'
                if (full_name, teacher, subject) in matched_pairs:
                    continue

                student_avail = self.student_data.get(full_name, {}).get("schedule", {})
                teacher_avail = self.teacher_data.get(teacher, {}).get("schedule", {})
                if not teacher_avail:
                    continue

                for date in sorted(student_avail.keys()):
                    if date not in teacher_avail:
                        continue

                    teacher_daily = teacher_daily_count.setdefault(teacher, {})
                    student_daily = student_daily_count.setdefault(full_name, {})

                    if teacher_daily.get(date, 0) >= 2:
                        continue
                    if student_daily.get(date, 0) >= 2:
                        continue
                    for time_slot, is_free in student_avail[date].items():
                        # print(time_slot)
                        if time_slot not in TIME_ROW_MAP:
                            continue
                        # print(teacher_avail[date].get(time_slot))
                        teacher_is_free = teacher_avail[date].get(time_slot, False)
                        # print(teacher_is_free)
                        # print(is_free, "===", teacher_is_free)
                        if is_free and teacher_is_free:
                            self.schedule_data.append({
                                'date': date,
                                'time': time_slot,
                                'student': full_name,
                                'teacher': teacher,
                                'subject': subject,
                                'type': subject_type,
                                'grade': grade
                            })
                            student_avail[date][time_slot] = False
                            teacher_avail[date][time_slot] = False
                            matched_pairs.add((full_name, teacher, subject))
                            teacher_daily[date] = teacher_daily.get(date, 0) + 1
                            student_daily[date] = student_daily.get(date, 0) + 1
                            break
                    
        self.date_order = sorted({entry['date'] for entry in self.schedule_data})

    def generate_teacher_excel(self):
        print(self.schedule_data)
        if not self.schedule_data:
            print("⚠️ No teacher data found — no file saved.")
            return

        if isinstance(self.teacher_template, str):
            self.teacher_template = load_workbook(self.teacher_template)

        template_wb = self.teacher_template  # Workbook object
        template_sheetnames = template_wb.sheetnames

        # Step 1: Build mapping from full teacher names to best-matched sheet name
        name_map = {}
        for entry in self.schedule_data:
            full_name = entry['teacher']
            match = None
            for sheet_name in template_sheetnames:
                if sheet_name == full_name:
                    match = sheet_name
                    break
                if full_name.startswith(sheet_name) and 1 <= len(sheet_name) <= 3:
                    match = sheet_name
                    break
            if match:
                name_map[full_name] = match
            else:
                print(f"⚠️ No matching sheet found for teacher: {full_name}")

        # Step 2: Write schedule to copied sheets in a new workbook
        output_wb = Workbook()
        output_wb.remove(output_wb.active)
        handled_teachers = set()

        for entry in self.schedule_data:
            teacher = entry['teacher']
            if teacher not in name_map:
                continue  # Skip unmatched

            template_sheetname = name_map[teacher]

            # Create a copy of the template sheet only once
            if teacher not in handled_teachers:
                template_ws = template_wb[template_sheetname]
                new_ws = copy_worksheet_template(output_wb, template_ws, teacher[:30])
                handled_teachers.add(teacher)
            else:
                new_ws = output_wb[teacher[:30]]

            # Fill the sheet
            row = int(TIME_ROW_MAP.get(entry['time'])) + self._date_to_row(entry['date']) * 8
            col = self._date_to_col(entry['date'])
            if col < 1 or row < 1:
                continue

            cell_primary = new_ws.cell(row=row, column=col)
            cell_secondary = new_ws.cell(row=row, column=col + 1)
            entry_text = f"{entry['student']}:{entry['subject']}"

            if not cell_primary.value:
                cell_primary.value = entry_text
            elif not cell_secondary.value:
                cell_secondary.value = entry_text
            else:
                print(f"⚠️ Both slots occupied on {entry['date']} at {entry['time']} for teacher {teacher}")

        os.makedirs(os.path.dirname(self.teacher_output_path), exist_ok=True)
        output_wb.save(self.teacher_output_path)



    def generate_student_excels(self):
        grouped_students = {'elementary': [], 'middle': [], 'high': []}
        for entry in self.schedule_data:
            grade = entry['grade']
            if grade in grouped_students:
                grouped_students[grade].append(entry)

        for category, entries in grouped_students.items():
            # print(entries)
            if not entries:
                continue

            wb = Workbook()
            wb.remove(wb.active)
            students = {entry['student'] for entry in entries}

            for student in students:
                wb_template = load_workbook(self.student_template)
                template_ws = wb_template.active
                ws_template = copy_worksheet_template(wb, template_ws, student[:30])

                for entry in entries:
                    if entry['student'] == student:
                        row = TIME_ROW_MAP.get(entry['time'])
                        if not row:
                            print(f"⚠️ Unknown time format: {entry['time']}")
                            continue
                        col = self._date_to_col(entry['date'])
                        if col < 1 or row < 1:
                            continue
                        ws_template.cell(row=row, column=col).value = entry['subject']
                        ws_template.cell(row=row, column=col + 1).value = entry['type']

            path = self.student_output_dirs[category]
            os.makedirs(os.path.dirname(path), exist_ok=True)
            wb.save(path)

    def _date_to_col(self, date_str):
        base_col = 3
        try:
            index = self.date_order.index(date_str)%5
        except ValueError:
            index = 0
        return base_col + index * 2

    def _date_to_row(self, date_str):
        try:
            index = int(self.date_order.index(date_str)%6)
            # print(index)
        except ValueError:
            index = 0
        return index 
